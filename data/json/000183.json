{"code": 0, "data": {"allow_search": false, "attention": false, "author_title": null, "blocked": false, "blocked_count": null, "can_del": false, "comments": [{"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 344, "create_time": 1599645332, "is_blocked": false, "is_tmp": false, "name_id": 0, "text": "另外的缺陷就是，如果撕破脸的话对面可以通过删掉这层楼击毙注册接口\n当然考虑到对方的意向的话，这应该不成问题", "timestamp": 1599645332}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 347, "create_time": 1599645778, "is_blocked": false, "is_tmp": false, "name_id": 1, "text": "Re : #66777无了。如果我的#66787也无了，那我就玩新洞了（", "timestamp": 1599645778}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 348, "create_time": 1599646042, "is_blocked": false, "is_tmp": false, "name_id": 0, "text": "保护新树洞管理员的身份的话，可以找一个不属于管理层的志愿者贡献“发帖用”Token，并运行以下服务（不属于“出借”）：\n- 从注册楼拉取新的注册请求\n- 发给新树洞的服务器\n- 新树洞服务器检查注册请求的合法性，然后把加密后的新树洞token发给志愿者\n- 志愿者使用自己的旧树洞Token回复注册者\n- 旧树洞管理员只知道志愿者的Token，而志愿者不属于新树洞管理层\n\n（这个协议稍作修改一下好像可以推广到“多个不可靠的志愿者”的情况，有请你洞学过分布式计算的大手子指正）", "timestamp": 1599646042}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 349, "create_time": 1599646187, "is_blocked": false, "is_tmp": false, "name_id": 0, "text": "由于旧树洞公约的限制以及安全的考虑，志愿者不能把Token直接借给新树洞管理层\n因此发帖这一半服务必须是跑在志愿者的机器上的", "timestamp": 1599646187}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 350, "create_time": 1599646436, "is_blocked": false, "is_tmp": false, "name_id": 2, "text": "有这闲工夫为什么不正经提供个认证接口🙄", "timestamp": 1599646436}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 351, "create_time": 1599646565, "is_blocked": false, "is_tmp": false, "name_id": 0, "text": "Re Bob: 看这架势旧洞并不想提供认证接口", "timestamp": 1599646565}, {"author_title": "", "blocked": false, "blocked_count": null, "can_del": false, "cid": 358, "create_time": 1599647215, "is_blocked": false, "is_tmp": false, "name_id": 0, "text": "另外的不需要管理员对旧树洞进行写入的方案：\n\n- 新树洞管理员弄到一个Token，并且由Bot控制\n- 新树洞管理员在旧树洞开一贴，“新树洞登录专楼”\n- 每次登陆（包括第一次注册）时，要求用户在该楼发布给定的随机字符串，由新树洞服务器进行验证\n- 旧树洞的每个身份对应新树洞的一个Token\n\n这样的漏洞是旧树洞管理员可以通过伪造回复骗到其他用户的Token（事实上旧树洞管理员无论如何都可以通过伪造回复骗到新的Token，但是被拿到全新的Token的损失小于被拿到其他人的Token），可以通过“仅允许注册但是不允许登录”解决", "timestamp": 1599647215}], "create_time": 1599645274, "cw": null, "hot_score": null, "is_blocked": false, "is_reported": null, "is_tmp": false, "last_comment_time": 1599645274, "likenum": 1, "n_attentions": 1, "n_comments": 7, "pid": 183, "poll": null, "reply": 7, "text": "隔壁洞#66574和#66777有感\n\n不“使用旧树洞的Token尝试登录”就能验证身份的办法也是存在的：\n\n- 新树洞管理员弄到一个Token（这可能会导致新树洞管理员的身份被泄露给旧树洞管理员），并且由Bot控制（不违反旧树洞公约）\n- 新树洞管理员在旧树洞开一贴，“新树洞注册专楼”\n- 用户在该贴下发布RSA公钥来注册\n- 所有第一次注册的用户，Bot会将Token使用公钥加密后回复给用户\n- 用户通过RSA私钥解密获得Token\n\n唯一漏洞就是这可能会导致新树洞管理员的身份被泄露给旧树洞管理员", "timestamp": 1599645274}}